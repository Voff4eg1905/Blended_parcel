{"mappings":"YAiBmB,CAAC,QAAS,MAAO,WAcRA,KAZ5B,SAAqBC,GACnB,OAAO,IAAIC,SAAQ,SAACC,EAASC,GAC3B,IAAMC,EAHmBC,KAAKC,KAAqB,IAAhBD,KAAKE,UAIxCC,YAAW,WACLJ,EAAQ,IACVF,EAAQ,CAAEF,YAAWS,MAAOL,IAE5BD,EAAO,CAAEH,YAAWS,MAAOL,EAAOM,MAAO,iB,GAE1CN,E,OAmGS,IAAIH,SAAQ,SAACC,EAASC,GACpCD,EAAQ,I,IAIPS,MAAK,SAAAC,GAEJ,OADAC,QAAQC,IAAIF,GACLA,C,IAERD,MAAK,SAAAC,GAEJ,GADAC,QAAQC,IAAIF,IACPA,EACH,MAAM,IAAIG,MAAM,kBAElB,MAAO,G,IAERJ,MAAK,SAAAC,GACJC,QAAQC,IAAIF,E,IAEbI,OAAM,SAAAN,GACLG,QAAQC,IAAIJ,E","sources":["src/js/promise.js"],"sourcesContent":["/*\n * Methods:\n * Promise.race(array) - повертає перший успішно виконаний або відхилений проміс, зі значенням чи причиною відхилення цього промісу.\n *\n * Promise.all(array) - повертає проміс, який виконається тоді, коли будуть успішно виконані всі проміси, або відхилено будь-який з них.\n *\n * Promise.allSettled(array) - повертає проміс, який виконується коли всі отримані проміси завершені (успішно виконані або відхилені), міститиме масив результатів отриманих промісів (status і value для успішних, status та reason для неуспішних)\n *\n * Promise.any(array) - як тільки один із промісів виконається успішно, метод поверне значення виконаного промісу. Якщо жоден із промісів не завершиться успішно, тоді повернутий Promise буде відхилено\n */\n// ================================\n/*\n * Зробіть 3 проміси - по одному для кожного фреймворку з масиву.\n * У кожному розташована функція setTimeout із випадковою затримкою від 0 до 2 секунд.\n * Зробити так, щоб проміси і резолвилися, і реджектилися випадково.\n * Нехай кожен проміс своїм результатом повертає цю затримку та ім'я фреймворку, а при помилці ще й текст помилки 'Promise error'.\n */\nconst frameworks = ['React', 'Vue', 'Angular'];\nconst getRandomDelay = () => Math.ceil(Math.random() * 2000);\nfunction makePromise(framework) {\n  return new Promise((resolve, reject) => {\n    const DELAY = getRandomDelay();\n    setTimeout(() => {\n      if (DELAY < 500) {\n        resolve({ framework, delay: DELAY });\n      } else {\n        reject({ framework, delay: DELAY, error: 'Promise error' });\n      }\n    }, DELAY);\n  });\n}\nconst promises = frameworks.map(makePromise);\nfunction onSuccess({ framework, delay }) {\n  console.log(`✅ ${framework} won with ${delay} ms`);\n}\nfunction onError({ framework, delay, error }) {\n  console.log(`❌ ${error}! ${framework} rejected in ${delay} ms`);\n}\n/*\n * За допомогою Promise.race дочекайтеся завантаження першого промісу, що спрацював, і виведіть результат його роботи на екран: `✅ ${Framework_name} won with ${delay} ms`\n * або результат помилки: `❌ ${error}! ${name} rejected in ${delay} ms`\n */\n// Promise.race(promises).then(onSuccess).catch(onError);\n/*\n * За допомогою Promise.all отримайте масив результатів\n * Виведіть на екран інформацію, з якою затримкою виконався проміс для кожного фреймфорка: `✅ ${Framework_name} fulfilled in ${delay} ms`\n * Або з якою затримкою зареджектився один із них: `❌ ${error}! ${Framework_name} rejected in ${delay} ms`\n */\n// Promise.all(promises)\n//   .then(res => res.forEach(onSuccess))\n//   .catch(onError);\n\n/*\n * За допомогою Promise.allSettled отримайте масив результатів.\n * Виведіть на екран інформацію, з яким результатом виконався проміс для кожного фреймфорка:\n * `✅ ${Framework_name} fulfilled in ${delay} ms`\n * `❌ ${error}! ${Framework_name} rejected in ${delay} ms`\n *\n * Приклад відповіді:\n * {status: \"fulfilled\", value: 99},\n * {status: \"rejected\", reason: Error: an error}\n */\n\n// Promise.allSettled(promises).then(res =>\n//   res.forEach(({ status, reason, value }) => {\n//     if (status === 'fulfilled') {\n//       onSuccess(value);\n//     } else {\n//       onError(reason);\n//     }\n//   })\n// );\n\n/*\n * За допомогою Promise.any дочекайтеся завантаження першого успішного промісу та виведіть результат його роботи на екран: `✅ ${Framework_name} won with ${delay} ms` або результат помилки кожного промісу в catch: `❌ ${error}! ${name} rejected in ${delay} ms`\n * Приклад об'єкта помилки в catch:\n * {\n * errors: (3) [{…}, {…}, {…}]\n * message: \"All promises were rejected\"\n * stack: \"AggregateError: All promises were rejected\"\n * }\n */\n\n// Promise.any(promises)\n//   .then(onSuccess)\n//   .catch(({ errors }) => {\n//     errors.forEach(onError);\n//   });\n//   .catch(({ errors, message, stack }) => console.dir(errors, message, stack));\n\n// setTimeout(() => {\n//   console.log('setTimeout');\n// }, 0);\n\n// console.log('console.log: 1');\n\n// Promise.resolve()\n//   .then(() => {\n//     console.log('promise: 1');\n//   })\n//   .then(() => {\n//     console.log('promise: 2');\n//   });\n\n// console.log('console.log: 2');\n\n// 'console.log: 1'  'console.log: 2'  'promise: 1' 'promise: 2' 'setTimeout'\n\n// const promise = new Promise((resolve, reject) => {\n//     resolve(1);\n//   reject(5);\n//   console.log('134');\n//   setTimeout(() => {\n//     resolve(2);\n//   }, 1000);\n// });\n\n// promise\n//   .then(result => {\n//     console.log(result);\n//   })\n//   .catch(err => {\n//     console.log(err);\n//   });\n\n//   console.log('134');  1\n\nconst promise = new Promise((resolve, reject) => {\n  resolve('1');\n});\n\npromise\n  .then(data => {\n    console.log(data);\n    return data;\n  })\n  .then(data => {\n    console.log(data);\n    if (!data) {\n      throw new Error('Error in then!');\n    }\n    return '2';\n  })\n  .then(data => {\n    console.log(data);\n  })\n  .catch(error => {\n    console.log(error);\n  });\n\n//   1  undefined  'Error in then!\n// 1     1    2\n"],"names":["map","framework","Promise","resolve","reject","DELAY","Math","ceil","random","setTimeout","delay","error","then","data","console","log","Error","catch"],"version":3,"file":"index.920eb5a8.js.map"}